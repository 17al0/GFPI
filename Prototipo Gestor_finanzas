import mysql.connector
from mysql.connector import Error
from decimal import Decimal

def get_db_connection():
    try:
        return mysql.connector.connect(
            host='localhost',
            user='root',
            password='italo',
            database='gestor_finanzas',
            charset='utf8'
        )
    except Error as e:
        print(f"Error al conectar a la base de datos: {e}")
        return None

class Transaccion:
    
    def __init__(self, monto, descripcion):
        self._monto = abs(monto)  # El monto siempre es positivo
        self._descripcion = descripcion
        self._tipo = None  # Se define en las subclases (+ o -)
    
    # Métodos GET para acceder a atributos encapsulados
    def get_tipo(self):
        return self._tipo
    
    def get_monto(self):
        return self._monto
    
    def get_descripcion(self):
        return self._descripcion
    
    # Método SET para cambiar la descripción
    def set_descripcion(self, nueva_descripcion):
        self._descripcion = nueva_descripcion
    
    # Método abstracto → debe implementarse en subclases
    def calcular_impacto(self):
        raise NotImplementedError("Debe implementarse en subclases.")
    
    # Representación en texto de la transacción
    def __str__(self):
        signo = '+' if self._tipo == '+' else '-'
        return f"{signo}${self._monto:.2f} - {self._descripcion}"

class Ingreso(Transaccion):
    def __init__(self, monto, descripcion):
        super().__init__(monto, descripcion)
        self._tipo = '+'
    
    def calcular_impacto(self):
        return self._monto  # Impacto positivo en el balance


class Gasto(Transaccion):
    def __init__(self, monto, descripcion):
        super().__init__(monto, descripcion)
        self._tipo = '-'
    
    def calcular_impacto(self):
        return -self._monto  # Impacto negativo en el balance

class GestorFinanzas:
    def __init__(self, id_usuario):
        self._id_usuario = id_usuario
        self._transacciones = self._cargar_transacciones()
        self._balance = sum((t.calcular_impacto() for t in self._transacciones), Decimal('0'))
    
    def _cargar_transacciones(self):
        conn = get_db_connection()
        if conn is None:
            print("Error: No se pudo cargar las transacciones desde la base de datos.")
            return []
        try:
            cursor = conn.cursor()
            cursor.execute("SELECT monto, descripcion, tipo FROM Transaccion WHERE id_usuario = %s ORDER BY fecha", (self._id_usuario,))
            rows = cursor.fetchall()
            trans = []
            for row in rows:
                monto, desc, tipo = row
                if tipo == '+':
                    t = Ingreso(monto, desc)
                else:
                    t = Gasto(monto, desc)
                trans.append(t)
            cursor.close()
            conn.close()
            return trans
        except Error as e:
            print(f"Error al cargar transacciones: {e}")
            if conn:
                conn.close()
            return []
    
    def get_balance(self):
        return self._balance
    
    def get_transacciones(self):
        return self._transacciones[:]  # Devuelve una copia (protege la lista)
    
    def set_balance(self, nuevo_balance):
        if isinstance(nuevo_balance, (int, float, Decimal)):
            self._balance = Decimal(nuevo_balance)
    
    def agregar_transaccion(self, transaccion):
        if isinstance(transaccion, Transaccion):
            self._transacciones.append(transaccion)
            self._balance += transaccion.calcular_impacto()
            print(f"Transacción agregada: {transaccion}")
            
            # Guardar en la base de datos
            conn = get_db_connection()
            if conn is None:
                print("Advertencia: No se pudo guardar la transacción en la base de datos.")
                return
            try:
                cursor = conn.cursor()
                tipo = transaccion.get_tipo()
                monto = transaccion.get_monto()
                desc = transaccion.get_descripcion()
                cursor.execute("INSERT INTO Transaccion (monto, descripcion, tipo, id_usuario) VALUES (%s, %s, %s, %s)",
                               (monto, desc, tipo, self._id_usuario))
                conn.commit()
                cursor.close()
                conn.close()
            except Error as e:
                print(f"Error al guardar transacción en la base de datos: {e}")
                if conn:
                    conn.close()
                # Nota: La transacción se mantiene en memoria para esta sesión, pero no se persistió
        else:
            print("Error: Solo se pueden agregar objetos de tipo Transaccion.")
    
    def ver_balance(self):
        print(f"\nBalance actual: ${self._balance:.2f}")
    
    def listar_transacciones(self):
        if not self._transacciones:
            print("\nNo hay transacciones registradas.")
            return
        print("\n--- Transacciones ---")
        for i, t in enumerate(self._transacciones, 1):
            print(f"{i}. {t}")

    def crear_y_agregar_transaccion(self):
        try:
            tipo = input("¿Es un ingreso (+) o gasto (-)? Ingresa '+' o '-': ").strip()
            if tipo not in ['+', '-']:
                print("Tipo inválido. Usa '+' para ingreso o '-' para gasto.")
                return
            
            monto_str = input("Ingresa el monto: ").strip()
            monto = Decimal(monto_str)
            descripcion = input("Ingresa una descripción: ").strip()
            
            if tipo == '+':
                transaccion = Ingreso(monto, descripcion)
            else:
                transaccion = Gasto(monto, descripcion)
            
            self.agregar_transaccion(transaccion)
        except ValueError:
            print("Monto inválido. Debe ser un número.")
        except Exception as e:
            print(f"Error inesperado: {e}")

class Usuario:
    def __init__(self, nombre, contrasena, id_usuario):
        self._nombre = nombre
        self._contrasena = contrasena  # En texto plano (mejorar luego con hash)
        self._id_usuario = id_usuario
        self._gestor = GestorFinanzas(id_usuario)
    
    def get_nombre(self):
        return self._nombre
    
    def get_gestor(self):
        return self._gestor
    
    def verificar_contrasena(self, contrasena):
        return self._contrasena == contrasena

def login_usuario():
    nombre = input("Ingresa tu nombre de usuario (o 'nuevo' para crear uno): ").strip().lower()
    
    if nombre == 'nuevo':
        nombre_nuevo = input("Ingresa un nombre de usuario nuevo: ").strip().lower()
        contrasena = input("Ingresa una contraseña: ").strip()
        contrasena_confirm = input("Confirma la contraseña: ").strip()
        if contrasena == "" or contrasena != contrasena_confirm:
            print("Las contraseñas no coinciden o están vacías. Intenta de nuevo.")
            return None
        
        conn = get_db_connection()
        if conn is None:
            return None
        try:
            cursor = conn.cursor()
            # Verificar si ya existe
            cursor.execute("SELECT 1 FROM Usuario WHERE nombre = %s", (nombre_nuevo,))
            if cursor.fetchone():
                print("Ese usuario ya existe. Usa otro nombre.")
                cursor.close()
                conn.close()
                return None
            
            # Insertar nuevo usuario
            cursor.execute("INSERT INTO Usuario (nombre, contrasena) VALUES (%s, %s)", (nombre_nuevo, contrasena))
            conn.commit()
            id_usuario = cursor.lastrowid
            cursor.close()
            conn.close()
            
            print(f"¡Usuario '{nombre_nuevo}' creado exitosamente! Balance inicial: $0.00")
            return Usuario(nombre_nuevo, contrasena, id_usuario)
        except Error as e:
            print(f"Error al crear usuario: {e}")
            if conn:
                conn.close()
            return None
    
    else:
        # Intentar login existente
        conn = get_db_connection()
        if conn is None:
            return None
        try:
            cursor = conn.cursor()
            cursor.execute("SELECT id_usuario, contrasena FROM Usuario WHERE nombre = %s", (nombre,))
            row = cursor.fetchone()
            cursor.close()
            conn.close()

            if row:
                id_usuario, contrasena_stored = row
                contrasena_input = input("Ingresa tu contraseña: ").strip()
                if contrasena_input == contrasena_stored:
                    print(f"¡Bienvenido de nuevo, {nombre}!")
                    return Usuario(nombre, contrasena_stored, id_usuario)
                else:
                    print("Contraseña incorrecta.")
                    return None
            else:
                print("Usuario no encontrado. Crea uno nuevo primero.")
                return None
        except Error as e:
            print(f"Error al verificar usuario: {e}")
            if conn:
                conn.close()
            return None

def menu(usuario):
    gestor = usuario.get_gestor()
    while True:
        print(f"\n=== Gestor de Finanzas - Usuario: {usuario.get_nombre()} ===")
        print("1. Agregar transacción")
        print("2. Ver balance")
        print("3. Listar transacciones")
        print("4. Cambiar de usuario")
        print("5. Salir")
        
        opcion = input("Elige una opción (1-5): ").strip()

        if opcion == '1':
            gestor.crear_y_agregar_transaccion()
        elif opcion == '2':
            gestor.ver_balance()
        elif opcion == '3':
            gestor.listar_transacciones()
        elif opcion == '4':
            print("Cerrando sesión...")
            return False  # Indica que debe hacer login de nuevo
        elif opcion == '5':
            print("¡Hasta luego!")
            return True  # Indica salida completa
        else:
            print("Opción inválida. Intenta de nuevo.")

if __name__ == "__main__":
    print("=== Bienvenido al Gestor de Finanzas Multi-Usuario con Contraseña ===")
    salir = False
    while not salir:
        usuario = login_usuario()
        if usuario is None:
            continue  # Vuelve a pedir login si falló
        salir_menu = menu(usuario)
        if salir_menu:
            salir = True
